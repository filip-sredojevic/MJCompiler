package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}


init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal String PROG;
terminal LBRACE, RBRACE, CONST, SEMI, ASSIGN, COMMA, LEFTBRACKET, RIGHTBRACKET, VOID, LPAREN, RPAREN, IF, BREAK, CONTINUE, RETURN; 
terminal READ, PRINT, DO, WHILE, ELSE, INCREMENT, DECREMENT, AND, OR, MAP, MINUS, NEW,  EQUAL, NOTEQUAL, GREATER, GREATEREQUAL, LESS, LESSEQUAL;
terminal PLUS, MUL, DIV, PERCENTAGE, UNION;
terminal SET, COLON, FULLSTOP; 
terminal String IDENT;
terminal Integer NUMBER, BOOL;
terminal Character CHARACTER;


nonterminal Program Program;
nonterminal ConVarDeclList ConVarDeclList;
nonterminal ConDeclList ConDeclList;
nonterminal ConDecl ConDecl;
nonterminal ConDeclMore ConDeclMore;
nonterminal Constant Constant;
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclMore VarDeclMore;
nonterminal MethodDecl MethodDecl;
nonterminal FormParsList FormParsList; 
nonterminal FormPar FormPar;
nonterminal FormParMore FormParMore;
nonterminal Statement Statement;
nonterminal StatementMultiple StatementMultiple;
nonterminal StatementSingle StatementSingle;
nonterminal StatementList StatementList; 
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseStatement ElseStatement;
nonterminal WhileStatement WhileStatement;
nonterminal Assignop Assignop;
nonterminal Setop Setop;
nonterminal ActParsList ActParsList;
nonterminal ActPar ActPar;
nonterminal ActParMore ActParMore;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal FactorSign FactorSign;
nonterminal Label Label;
nonterminal Do Do;
nonterminal MethodDeclList MethodDeclList;
nonterminal VarDeclListMethod VarDeclListMethod;
nonterminal ProgramName ProgramName; 
nonterminal Else Else;
nonterminal If If;
nonterminal Break Break;
nonterminal While While;

nonterminal  rs.etf.pp1.symboltable.concepts.Struct FactorValue;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct FactorList;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct TermList;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct Expr;

nonterminal  rs.etf.pp1.symboltable.concepts.Struct CondFact, CondFactList, CondTerm, CondTermList, Condition;

nonterminal  rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal  rs.etf.pp1.symboltable.concepts.Obj DesignatorArrayName;


/* Cetvrta faza */
nonterminal  rs.etf.pp1.symboltable.concepts.Obj MethodRetTypeName;
nonterminal  rs.etf.pp1.symboltable.concepts.Struct Type;

precedence left ELSE;

Program ::= (Program) PROG:P1 ProgramName:P2 ConVarDeclList:C3 LBRACE MethodDeclList:M4 RBRACE {: RESULT=new Program(P1, P2, C3, M4); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:I1 {: RESULT=new ProgramName(I1); RESULT.setLine(I1left); :};


ConVarDeclList ::= (ConVarDeclListCon) ConVarDeclList:C1 ConDeclList:C2 {: RESULT=new ConVarDeclListCon(C1, C2); RESULT.setLine(C1left); :}
              |   (ConVarDecListVar) ConVarDeclList:C1 VarDeclList:V2 {: RESULT=new ConVarDecListVar(C1, V2); RESULT.setLine(C1left); :}
              |   (ConVarDecListEpsilon) {: RESULT=new ConVarDecListEpsilon(); :} /*epsilon*/
              ;

ConDeclList ::= (ConDeclList) CONST Type:T1 ConDecl:C2 ConDeclMore:C3 SEMI {: RESULT=new ConDeclList(T1, C2, C3); RESULT.setLine(T1left); :};

ConDeclMore ::= (ConstDeclMoreComma) COMMA ConDecl:C1 ConDeclMore:C2 {: RESULT=new ConstDeclMoreComma(C1, C2); RESULT.setLine(C1left); :}
               |  (ConstDeclMoreEpsilon) {: RESULT=new ConstDeclMoreEpsilon(); :} /*epsilon*/
               ;

ConDecl ::= (ConDecl) IDENT:I1 ASSIGN Constant:C2 {: RESULT=new ConDecl(I1, C2); RESULT.setLine(I1left); :};
        

Constant ::= (NumConst) NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
       | (CharConst) CHARACTER:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
       | (BoolConst) BOOL:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
       ;
       
Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};

VarDeclList ::= (VarDeclList) Type:T1 VarDecl:V2 VarDeclMore:V3 SEMI {: RESULT=new VarDeclList(T1, V2, V3); RESULT.setLine(T1left); :};
   
VarDeclMore ::= (VarDeclMoreComma) COMMA VarDecl:V1 VarDeclMore:V2 {: RESULT=new VarDeclMoreComma(V1, V2); RESULT.setLine(V1left); :} 
				| (VarDeclMoreEpsilon) {: RESULT=new VarDeclMoreEpsilon(); :} /* epsilon */
				;                        
            
VarDecl ::= (VarDeclVar) IDENT:I1 {: RESULT=new VarDeclVar(I1); RESULT.setLine(I1left); :}  
		|   (VarDeclArray) IDENT:I1 LEFTBRACKET RIGHTBRACKET {: RESULT=new VarDeclArray(I1); RESULT.setLine(I1left); :}
		;
		
		
			
MethodDecl ::= (MethodDecl) MethodRetTypeName:M1 LPAREN FormParsList:F2 RPAREN VarDeclListMethod:V3  LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(M1, F2, V3, S4); RESULT.setLine(M1left); :};                
                
MethodRetTypeName ::= (MethodRetTypeNameNoVoid) Type:T1 IDENT:I2 {: RESULT=new MethodRetTypeNameNoVoid(T1, I2); RESULT.setLine(T1left); :}
                   |  (MethodRetTypeNameVoid) VOID IDENT:I1 {: RESULT=new MethodRetTypeNameVoid(I1); RESULT.setLine(I1left); :}
                   ;

VarDeclListMethod ::= (VarDeclListMethodExpand) VarDeclListMethod:V1 VarDeclList:V2 {: RESULT=new VarDeclListMethodExpand(V1, V2); RESULT.setLine(V1left); :}
                | (VarDeclListMethodEpsilon) {: RESULT=new VarDeclListMethodEpsilon(); :} /*epsilon*/
                ;

MethodDeclList ::= (MethodDeclListExpand) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListExpand(M1, M2); RESULT.setLine(M1left); :}
                | (MethodDeclListTerminate) {: RESULT=new MethodDeclListTerminate(); :} /* epsilon */
                ;			 

				
FormParsList ::= (FormParsListExpand) FormPar:F1 FormParMore:F2 {: RESULT=new FormParsListExpand(F1, F2); RESULT.setLine(F1left); :}
              | (FormParsListEpsilon) {: RESULT=new FormParsListEpsilon(); :} /*epsilon*/
              ;


FormPar ::= (FormParVar) Type:T1 IDENT:I2 {: RESULT=new FormParVar(T1, I2); RESULT.setLine(T1left); :}
         |  (FormParArray) Type:T1 IDENT:I2 LEFTBRACKET RIGHTBRACKET {: RESULT=new FormParArray(T1, I2); RESULT.setLine(T1left); :}
         ;

FormParMore ::= (FormParMoreComma) COMMA FormPar:F1 FormParMore:F2 {: RESULT=new FormParMoreComma(F1, F2); RESULT.setLine(F1left); :}
             | (FormParMoreEpsilon) {: RESULT=new FormParMoreEpsilon(); :} /*epsilon*/
             ;				

Statement ::= (StatementOne) StatementSingle:S1 {: RESULT=new StatementOne(S1); RESULT.setLine(S1left); :} 
          |   (StatementMore) StatementMultiple:S1 {: RESULT=new StatementMore(S1); RESULT.setLine(S1left); :} 
          ;

StatementMultiple ::= (StatementMultiple) LBRACE StatementList:S1 RBRACE {: RESULT=new StatementMultiple(S1); RESULT.setLine(S1left); :};

StatementList ::= (StatementListExpand) StatementList:S1 StatementSingle:S2 {: RESULT=new StatementListExpand(S1, S2); RESULT.setLine(S1left); :}
              |   (StatementListEpsilon) {: RESULT=new StatementListEpsilon(); :} /*epsilon*/
              ;
              
              
StatementSingle ::= (StatementSingleDesignator) DesignatorStatement:D1 SEMI {: RESULT=new StatementSingleDesignator(D1); RESULT.setLine(D1left); :}
                 | (StatementSingleIfElse) If:I1 LPAREN Condition:C2 RPAREN Statement:S3 ElseStatement:E4 {: RESULT=new StatementSingleIfElse(I1, C2, S3, E4); RESULT.setLine(I1left); :}
                 | (StatementSingleBreak) Break:B1 SEMI {: RESULT=new StatementSingleBreak(B1); RESULT.setLine(B1left); :}
                 | (StatementSingleContinue) CONTINUE SEMI {: RESULT=new StatementSingleContinue(); :}
                 | (StatementSingleReturnNoArg) RETURN SEMI {: RESULT=new StatementSingleReturnNoArg(); :} 
                 | (StatementSingleReturnArg) RETURN Expr:E1 SEMI {: RESULT=new StatementSingleReturnArg(E1); RESULT.setLine(E1left); :}
                 | (StatementSingleRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementSingleRead(D1); RESULT.setLine(D1left); :}
                 | (StatementSinglePrint1) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatementSinglePrint1(E1); RESULT.setLine(E1left); :}
                 | (StatementSinglePrint2) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new StatementSinglePrint2(E1, N2); RESULT.setLine(E1left); :}
                 | (StatementSingleDoWHILE) Do:D1 Statement:S2 While:W3 LPAREN WhileStatement:W4 RPAREN SEMI {: RESULT=new StatementSingleDoWHILE(D1, S2, W3, W4); RESULT.setLine(D1left); :}
                 ;
                 
While ::= (While) WHILE {: RESULT=new While(); :};                 
                 
Break ::= (Break) BREAK {: RESULT=new Break(); :};                 
                 
If ::= (If) IF {: RESULT=new If(); :};                 
                 
Do ::=(Do) DO {: RESULT=new Do(); :};                
                 
ElseStatement ::= (ElseStatementExist) Else:E1 Statement:S2 {: RESULT=new ElseStatementExist(E1, S2); RESULT.setLine(E1left); :}
              | (ElseStatementEpsilon) {: RESULT=new ElseStatementEpsilon(); :} /* epsilon */
              ;                                  

Else ::= (Else) ELSE {: RESULT=new Else(); :};

WhileStatement  ::= (WhileStatementCondition) Condition:C1 {: RESULT=new WhileStatementCondition(C1); RESULT.setLine(C1left); :}
                 | (WhileStatementDs) Condition:C1 COMMA DesignatorStatement:D2 {: RESULT=new WhileStatementDs(C1, D2); RESULT.setLine(C1left); :}
                 | (WhileStatementEpsilon) {: RESULT=new WhileStatementEpsilon(); :} /* epsilon */
                 ;           
                                
                 
DesignatorStatement  ::= (DesignatorStatementAssign) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStatementAssign(D1, A2, E3); RESULT.setLine(D1left); :}   
                      | (DesignatorStatementActPar) Designator:D1 LPAREN ActParsList:A2 RPAREN {: RESULT=new DesignatorStatementActPar(D1, A2); RESULT.setLine(D1left); :} /* meth(); */
                      | (DesignatorStatementInc) Designator:D1 INCREMENT {: RESULT=new DesignatorStatementInc(D1); RESULT.setLine(D1left); :}
                      | (DesignatorStatementDec) Designator:D1 DECREMENT {: RESULT=new DesignatorStatementDec(D1); RESULT.setLine(D1left); :}
                      | (DesignatorStatementSetop) Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 {: RESULT=new DesignatorStatementSetop(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
                      ;             
                
ActParsList ::= (ActParsListExist) ActPar:A1 ActParMore:A2 {: RESULT=new ActParsListExist(A1, A2); RESULT.setLine(A1left); :}
             |  (ActParsListEpsilon) {: RESULT=new ActParsListEpsilon(); :} /* epsilon */
             ;

ActParMore  ::= (ActParMoreExist) COMMA ActPar:A1 ActParMore:A2 {: RESULT=new ActParMoreExist(A1, A2); RESULT.setLine(A1left); :}
              | (ActParMoreEpsilon) {: RESULT=new ActParMoreEpsilon(); :} /* epsilon */
              ;

ActPar ::= (ActPar) Expr:E1 {: RESULT=new ActPar(E1); RESULT.setLine(E1left); :};


Condition ::= (Condition) CondTermList:C1 {: RESULT=new Condition(C1); RESULT.setLine(C1left); :};

CondTermList ::= (CondTermListExpand) CondTermList:C1 OR CondTerm:C2 {: RESULT=new CondTermListExpand(C1, C2); RESULT.setLine(C1left); :}
              | (CondTermListTerminate) CondTerm:C1 {: RESULT=new CondTermListTerminate(C1); RESULT.setLine(C1left); :}
              ;   

CondTerm ::= (CondTerm) CondFactList:C1 {: RESULT=new CondTerm(C1); RESULT.setLine(C1left); :};

CondFactList  ::= (CondFactListExpand) CondFactList:C1 AND CondFact:C2 {: RESULT=new CondFactListExpand(C1, C2); RESULT.setLine(C1left); :}  
               | (CondFactListTerminate) CondFact:C1 {: RESULT=new CondFactListTerminate(C1); RESULT.setLine(C1left); :}
               ;      

CondFact ::= (CondFact1) Expr:E1 {: RESULT=new CondFact1(E1); RESULT.setLine(E1left); :}
          | (CondFact2) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFact2(E1, R2, E3); RESULT.setLine(E1left); :}
          ;  

Expr ::= (ExprTerm) TermList:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :}
       | (ExprDesignator) Designator:D1 MAP DesignatorArrayName:D2 {: RESULT=new ExprDesignator(D1, D2); RESULT.setLine(D1left); :}
       ;    
       
TermList ::= (TermListExpand) TermList:T1 Addop:A2 Term:T3 {: RESULT=new TermListExpand(T1, A2, T3); RESULT.setLine(T1left); :}
          | (TermListTerminate) Term:T1 {: RESULT=new TermListTerminate(T1); RESULT.setLine(T1left); :}
          ;       
       
      
Term ::= (Term) FactorList:F1 {: RESULT=new Term(F1); RESULT.setLine(F1left); :};       
       	   

FactorList ::= (FactorListExpand) FactorList:F1 Mulop:M2 Factor:F3 {: RESULT=new FactorListExpand(F1, M2, F3); RESULT.setLine(F1left); :}
           | (FactorListTerminate) Factor:F1 {: RESULT=new FactorListTerminate(F1); RESULT.setLine(F1left); :}
           ;
          

Factor ::= (Factor1) MINUS FactorValue:F1 {: RESULT=new Factor1(F1); RESULT.setLine(F1left); :}
          | (Factor2) FactorValue:F1 {: RESULT=new Factor2(F1); RESULT.setLine(F1left); :}
          ;


FactorValue ::= (FactorValueVar) Designator:D1 {: RESULT=new FactorValueVar(D1); RESULT.setLine(D1left); :} 
             | (FactorValueMethod) Designator:D1 LPAREN ActParsList:A2 RPAREN {: RESULT=new FactorValueMethod(D1, A2); RESULT.setLine(D1left); :}  /* x= meth(); x = meth(_) + 100; */
             | (FactorValueNumber) NUMBER:N1 {: RESULT=new FactorValueNumber(N1); RESULT.setLine(N1left); :} 
             | (FactorValueCharacter) CHARACTER:C1 {: RESULT=new FactorValueCharacter(C1); RESULT.setLine(C1left); :}
             | (FactorValueBool) BOOL:B1 {: RESULT=new FactorValueBool(B1); RESULT.setLine(B1left); :}
             | (FactorValueArray) NEW Type:T1 LEFTBRACKET Expr:E2 RIGHTBRACKET {: RESULT=new FactorValueArray(T1, E2); RESULT.setLine(T1left); :}
             | (FactorValueExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorValueExpr(E1); RESULT.setLine(E1left); :}   
             ;   
              
Designator ::= (DesignatorIdent) IDENT:I1 {: RESULT=new DesignatorIdent(I1); RESULT.setLine(I1left); :} 
            |  (DesignatorElemArray) DesignatorArrayName:D1  LEFTBRACKET Expr:E2 RIGHTBRACKET {: RESULT=new DesignatorElemArray(D1, E2); RESULT.setLine(D1left); :}
            ; 
DesignatorArrayName ::= (DesignatorArrayName) IDENT:I1 {: RESULT=new DesignatorArrayName(I1); RESULT.setLine(I1left); :};

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};


Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};


Relop ::= (RelopEqual) EQUAL {: RESULT=new RelopEqual(); :}
       |  (RelopNoEqual) NOTEQUAL {: RESULT=new RelopNoEqual(); :}
       |  (RelopGreater) GREATER {: RESULT=new RelopGreater(); :}
       |  (RelopGreaterEqual) GREATEREQUAL {: RESULT=new RelopGreaterEqual(); :}
       |  (RelopLess) LESS {: RESULT=new RelopLess(); :}
       |  (RelopLessEqual) LESSEQUAL {: RESULT=new RelopLessEqual(); :}
       ;


Addop ::= (AddopPlus) PLUS {: RESULT=new AddopPlus(); :}
       | (AddopMinus) MINUS {: RESULT=new AddopMinus(); :}
       ;


Mulop ::= (MulopMul) MUL {: RESULT=new MulopMul(); :}
      |  (MulopDiv) DIV {: RESULT=new MulopDiv(); :}
      |  (MulopPer) PERCENTAGE {: RESULT=new MulopPer(); :}         
      ;
    
      
Setop ::= (Setop) UNION {: RESULT=new Setop(); :};

